/*
GraphHopper Directions API

 Integrate A-to-B route planning, turn-by-turn navigation, route optimization, isochrone calculations, location clustering and other tools into your application.    ##### Authentication      1. [Sign up for GraphHopper](https://graphhopper.com/dashboard/#/signup)   2. [Create an API key](https://support.graphhopper.com/a/solutions/articles/44001976027)    Authenticate to the API by passing your key as a query parameter in every request.    ##### API Explorer    You can also try all API parts without registration in our [API explorer](https://explorer.graphhopper.com/).    ##### Client Libraries    To speed up development and make coding easier, we offer a [JavaScript client](https://github.com/graphhopper/directions-api-js-client) and a   [Java client](https://github.com/graphhopper/graphhopper/tree/master/client-hc).    ##### Optimize Response Speed    1. Reuse SSL/TLS sessions    You should utilize the SSL session to speed up responses after the initial response or use a library that does this. E.g. for Java the   [OkHttp library](https://square.github.io/okhttp/) automatically reuses SSL/TLS sessions and also the browser takes care of this automatically.   For python you can use the [`requests` library](https://requests.readthedocs.io/en/latest/user/advanced/): first you create a   session (`session = requests.Session()`) and then do requests only with this session instead of directly using \"requests\".    2. Bandwidth reduction    If you create your own client, make sure it supports http/2 and gzipped responses for best speed.   If you use the Matrix, the Route Optimization API or the  and want to solve large problems, we recommend you to reduce bandwidth   by [compressing your POST request](https://gist.github.com/karussell/82851e303ea7b3459b2dea01f18949f4) and specifying the header   as follows: `Content-Encoding: gzip`. This will also avoid the HTTP 413 error \"Request Entity Too Large\". 

API version: 1.0.0
Contact: support@graphhopper.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
)


// RoutingAPIService RoutingAPI service
type RoutingAPIService service

type ApiGetRouteRequest struct {
	ctx context.Context
	ApiService *RoutingAPIService
	point *[]string
	profile *string
	pointHint *[]string
	snapPrevention *[]string
	curbside *[]string
	locale *string
	elevation *bool
	details *[]string
	optimize *string
	instructions *bool
	calcPoints *bool
	debug *bool
	pointsEncoded *bool
	chDisable *bool
	heading *[]int32
	headingPenalty *int32
	passThrough *bool
	algorithm *string
	roundTripDistance *int32
	roundTripSeed *int64
	alternativeRouteMaxPaths *int32
	alternativeRouteMaxWeightFactor *float32
	alternativeRouteMaxShareFactor *float32
}

// The points for which the route should be calculated. Format: &#x60;latitude,longitude&#x60;. Specify at least an origin and a destination. Via points are possible. The maximum number depends on your plan. 
func (r ApiGetRouteRequest) Point(point []string) ApiGetRouteRequest {
	r.point = &point
	return r
}

func (r ApiGetRouteRequest) Profile(profile string) ApiGetRouteRequest {
	r.profile = &profile
	return r
}

// The &#x60;point_hint&#x60; is typically a road name to which the associated &#x60;point&#x60; parameter should be snapped to. Specify no &#x60;point_hint&#x60; parameter or the same number as you have &#x60;point&#x60; parameters. 
func (r ApiGetRouteRequest) PointHint(pointHint []string) ApiGetRouteRequest {
	r.pointHint = &pointHint
	return r
}

// Optional parameter. &#39;Snapping&#39; is the process of finding the closest road location for GPS coordinates provided in the &#x60;point&#x60; parameter. The &#x60;snap_prevention&#x60; parameter allows you to prevent snapping to specific types of roads. For example, if &#x60;snap_prevention&#x60; is set to bridge, the routing engine will avoid snapping to a bridge, even if it is the closest road for the given &#x60;point&#x60;. Current supported values: &#x60;motorway&#x60;, &#x60;trunk&#x60;, &#x60;ferry&#x60;, &#x60;tunnel&#x60;, &#x60;bridge&#x60; and &#x60;ford&#x60;. Multiple values are specified like &#x60;snap_prevention&#x3D;ferry&amp;snap_prevention&#x3D;motorway&#x60;. Note that once snapped the routing algorithm can still route over bridges (or the other values). To avoid this you need to use the &#x60;custom_model&#x60;. 
func (r ApiGetRouteRequest) SnapPrevention(snapPrevention []string) ApiGetRouteRequest {
	r.snapPrevention = &snapPrevention
	return r
}

// Optional parameter. It specifies on which side a point should be relative to the driver when she leaves/arrives at a start/target/via point. You need to specify this parameter for either none or all points. Only supported for motor vehicles and OpenStreetMap. 
func (r ApiGetRouteRequest) Curbside(curbside []string) ApiGetRouteRequest {
	r.curbside = &curbside
	return r
}

// The locale of the resulting turn instructions. E.g. &#x60;pt_PT&#x60; for Portuguese or &#x60;de&#x60; for German. 
func (r ApiGetRouteRequest) Locale(locale string) ApiGetRouteRequest {
	r.locale = &locale
	return r
}

// If &#x60;true&#x60;, a third coordinate, the altitude, is included with all positions in the response. This changes the format of the &#x60;points&#x60; and &#x60;snapped_waypoints&#x60; fields of the response, in both their encodings. Unless you switch off the &#x60;points_encoded&#x60; parameter, you need special code on the client side that can handle three-dimensional coordinates. 
func (r ApiGetRouteRequest) Elevation(elevation bool) ApiGetRouteRequest {
	r.elevation = &elevation
	return r
}

// Optional parameter. The following path details are available: &#x60;street_name&#x60;, &#x60;street_ref&#x60;, &#x60;street_destination&#x60;, &#x60;leg_time&#x60;, &#x60;leg_distance&#x60;, &#x60;roundabout&#x60;, &#x60;country&#x60;, &#x60;time&#x60;, &#x60;distance&#x60;, &#x60;max_speed&#x60;, &#x60;max_weight&#x60;, &#x60;max_width&#x60;, &#x60;toll&#x60;, &#x60;road_class&#x60;, &#x60;road_class_link&#x60;, &#x60;road_access&#x60;, &#x60;road_environment&#x60;, &#x60;hazmat&#x60;, &#x60;hazmat_tunnel&#x60;, &#x60;hazmat_water&#x60;,  &#x60;lanes&#x60;, &#x60;surface&#x60;, &#x60;smoothness&#x60;, &#x60;hike_rating&#x60;, &#x60;mtb_rating&#x60;, &#x60;foot_network&#x60;, &#x60;bike_network&#x60;. Read more about the usage of path details [here](https://discuss.graphhopper.com/t/2539). 
func (r ApiGetRouteRequest) Details(details []string) ApiGetRouteRequest {
	r.details = &details
	return r
}

// Normally, the calculated route will visit the points in the order you specified them. If you have more than two points, you can set this parameter to &#x60;\&quot;true\&quot;&#x60; and the points may be re-ordered to minimize the total travel time. Keep in mind that the limits on the number of locations of the Route Optimization API applies, and the request costs more credits. 
func (r ApiGetRouteRequest) Optimize(optimize string) ApiGetRouteRequest {
	r.optimize = &optimize
	return r
}

// If instructions should be calculated and returned 
func (r ApiGetRouteRequest) Instructions(instructions bool) ApiGetRouteRequest {
	r.instructions = &instructions
	return r
}

// If the points for the route should be calculated at all. 
func (r ApiGetRouteRequest) CalcPoints(calcPoints bool) ApiGetRouteRequest {
	r.calcPoints = &calcPoints
	return r
}

// If &#x60;true&#x60;, the output will be formatted. 
func (r ApiGetRouteRequest) Debug(debug bool) ApiGetRouteRequest {
	r.debug = &debug
	return r
}

// Allows changing the encoding of location data in the response. The default is polyline encoding, which is compact but requires special client code to unpack. (We provide it in our JavaScript client library!) Set this parameter to &#x60;false&#x60; to switch the encoding to simple coordinate pairs like &#x60;[lon,lat]&#x60;, or &#x60;[lon,lat,elevation]&#x60;. See the description of the response format for more information. 
func (r ApiGetRouteRequest) PointsEncoded(pointsEncoded bool) ApiGetRouteRequest {
	r.pointsEncoded = &pointsEncoded
	return r
}

// Combine this parameter with any of the following options below. 
func (r ApiGetRouteRequest) ChDisable(chDisable bool) ApiGetRouteRequest {
	r.chDisable = &chDisable
	return r
}

// Favour a heading direction for a certain point. Specify either one heading for the start point or as many as there are points. In this case headings are associated by their order to the specific points. Headings are given as north based clockwise angle between 0 and 360 degree. This parameter also influences the tour generated with &#x60;algorithm&#x3D;round_trip&#x60; and forces the initial direction.  Requires &#x60;ch.disable&#x3D;true&#x60;. 
func (r ApiGetRouteRequest) Heading(heading []int32) ApiGetRouteRequest {
	r.heading = &heading
	return r
}

// Time penalty in seconds for not obeying a specified heading. Requires &#x60;ch.disable&#x3D;true&#x60;. 
func (r ApiGetRouteRequest) HeadingPenalty(headingPenalty int32) ApiGetRouteRequest {
	r.headingPenalty = &headingPenalty
	return r
}

// If &#x60;true&#x60;, u-turns are avoided at via-points with regard to the &#x60;heading_penalty&#x60;. Requires &#x60;ch.disable&#x3D;true&#x60;. 
func (r ApiGetRouteRequest) PassThrough(passThrough bool) ApiGetRouteRequest {
	r.passThrough = &passThrough
	return r
}

// Rather than looking for the shortest or fastest path, this parameter lets you solve two different problems related to routing: With &#x60;alternative_route&#x60;, we give you not one but several routes that are close to optimal, but not too similar to each other.  With &#x60;round_trip&#x60;, the route will get you back to where you started. This is meant for fun (think of a bike trip), so we will add some randomness. The &#x60;round_trip&#x60; option requires &#x60;ch.disable&#x3D;true&#x60;. You can control both of these features with additional parameters, see below.  
func (r ApiGetRouteRequest) Algorithm(algorithm string) ApiGetRouteRequest {
	r.algorithm = &algorithm
	return r
}

// If &#x60;algorithm&#x3D;round_trip&#x60;, this parameter configures approximative length of the resulting round trip. Requires &#x60;ch.disable&#x3D;true&#x60;. 
func (r ApiGetRouteRequest) RoundTripDistance(roundTripDistance int32) ApiGetRouteRequest {
	r.roundTripDistance = &roundTripDistance
	return r
}

// If &#x60;algorithm&#x3D;round_trip&#x60;, this sets the random seed. Change this to get a different tour for each value. 
func (r ApiGetRouteRequest) RoundTripSeed(roundTripSeed int64) ApiGetRouteRequest {
	r.roundTripSeed = &roundTripSeed
	return r
}

// If &#x60;algorithm&#x3D;alternative_route&#x60;, this parameter sets the number of maximum paths which should be calculated. Increasing can lead to worse alternatives. 
func (r ApiGetRouteRequest) AlternativeRouteMaxPaths(alternativeRouteMaxPaths int32) ApiGetRouteRequest {
	r.alternativeRouteMaxPaths = &alternativeRouteMaxPaths
	return r
}

// If &#x60;algorithm&#x3D;alternative_route&#x60;, this parameter sets the factor by which the alternatives routes can be longer than the optimal route. Increasing can lead to worse alternatives. 
func (r ApiGetRouteRequest) AlternativeRouteMaxWeightFactor(alternativeRouteMaxWeightFactor float32) ApiGetRouteRequest {
	r.alternativeRouteMaxWeightFactor = &alternativeRouteMaxWeightFactor
	return r
}

// If &#x60;algorithm&#x3D;alternative_route&#x60;, this parameter specifies how similar an alternative route can be to the optimal route. Increasing can lead to worse alternatives. 
func (r ApiGetRouteRequest) AlternativeRouteMaxShareFactor(alternativeRouteMaxShareFactor float32) ApiGetRouteRequest {
	r.alternativeRouteMaxShareFactor = &alternativeRouteMaxShareFactor
	return r
}

func (r ApiGetRouteRequest) Execute() (*RouteResponse, *http.Response, error) {
	return r.ApiService.GetRouteExecute(r)
}

/*
GetRoute Calculate a route

For the GET request you specify the parameters in the URL and can try it directly in every browser.
However, it has some disadvantages when using many points (URL length limit) and the [`custom_model` Feature](#tag/Custom-Model) cannot be used. 
Therefore, our recommended endpoint is the [POST route endpoint](#operation/postRoute).


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRouteRequest
*/
func (a *RoutingAPIService) GetRoute(ctx context.Context) ApiGetRouteRequest {
	return ApiGetRouteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RouteResponse
func (a *RoutingAPIService) GetRouteExecute(r ApiGetRouteRequest) (*RouteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RouteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoutingAPIService.GetRoute")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/route"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.point == nil {
		return localVarReturnValue, nil, reportError("point is required and must be specified")
	}

	if r.profile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profile", r.profile, "form", "")
	} else {
		var defaultValue string = "car"
		r.profile = &defaultValue
	}
	{
		t := *r.point
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "point", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "point", t, "form", "multi")
		}
	}
	if r.pointHint != nil {
		t := *r.pointHint
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "point_hint", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "point_hint", t, "form", "multi")
		}
	}
	if r.snapPrevention != nil {
		t := *r.snapPrevention
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "snap_prevention", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "snap_prevention", t, "form", "multi")
		}
	}
	if r.curbside != nil {
		t := *r.curbside
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "curbside", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "curbside", t, "form", "multi")
		}
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "form", "")
	} else {
		var defaultValue string = "en"
		r.locale = &defaultValue
	}
	if r.elevation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "elevation", r.elevation, "form", "")
	} else {
		var defaultValue bool = false
		r.elevation = &defaultValue
	}
	if r.details != nil {
		t := *r.details
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "details", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "details", t, "form", "multi")
		}
	}
	if r.optimize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "optimize", r.optimize, "form", "")
	} else {
		var defaultValue string = "false"
		r.optimize = &defaultValue
	}
	if r.instructions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instructions", r.instructions, "form", "")
	} else {
		var defaultValue bool = true
		r.instructions = &defaultValue
	}
	if r.calcPoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "calc_points", r.calcPoints, "form", "")
	} else {
		var defaultValue bool = true
		r.calcPoints = &defaultValue
	}
	if r.debug != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "debug", r.debug, "form", "")
	} else {
		var defaultValue bool = false
		r.debug = &defaultValue
	}
	if r.pointsEncoded != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "points_encoded", r.pointsEncoded, "form", "")
	} else {
		var defaultValue bool = true
		r.pointsEncoded = &defaultValue
	}
	if r.chDisable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ch.disable", r.chDisable, "form", "")
	} else {
		var defaultValue bool = false
		r.chDisable = &defaultValue
	}
	if r.heading != nil {
		t := *r.heading
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "heading", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "heading", t, "form", "multi")
		}
	}
	if r.headingPenalty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "heading_penalty", r.headingPenalty, "form", "")
	} else {
		var defaultValue int32 = 300
		r.headingPenalty = &defaultValue
	}
	if r.passThrough != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pass_through", r.passThrough, "form", "")
	} else {
		var defaultValue bool = false
		r.passThrough = &defaultValue
	}
	if r.algorithm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "algorithm", r.algorithm, "form", "")
	}
	if r.roundTripDistance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "round_trip.distance", r.roundTripDistance, "form", "")
	} else {
		var defaultValue int32 = 10000
		r.roundTripDistance = &defaultValue
	}
	if r.roundTripSeed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "round_trip.seed", r.roundTripSeed, "form", "")
	}
	if r.alternativeRouteMaxPaths != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "alternative_route.max_paths", r.alternativeRouteMaxPaths, "form", "")
	} else {
		var defaultValue int32 = 2
		r.alternativeRouteMaxPaths = &defaultValue
	}
	if r.alternativeRouteMaxWeightFactor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "alternative_route.max_weight_factor", r.alternativeRouteMaxWeightFactor, "form", "")
	} else {
		var defaultValue float32 = 1.4
		r.alternativeRouteMaxWeightFactor = &defaultValue
	}
	if r.alternativeRouteMaxShareFactor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "alternative_route.max_share_factor", r.alternativeRouteMaxShareFactor, "form", "")
	} else {
		var defaultValue float32 = 0.6
		r.alternativeRouteMaxShareFactor = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GHError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GHError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GHError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GHError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostRouteRequest struct {
	ctx context.Context
	ApiService *RoutingAPIService
	routeRequest *RouteRequest
}

func (r ApiPostRouteRequest) RouteRequest(routeRequest RouteRequest) ApiPostRouteRequest {
	r.routeRequest = &routeRequest
	return r
}

func (r ApiPostRouteRequest) Execute() (*RouteResponse, *http.Response, error) {
	return r.ApiService.PostRouteExecute(r)
}

/*
PostRoute Calculate a route

To do a request you send JSON data. 

See the [GET endpoint](#operation/getRoute) for an alternative query method which is slightly simpler to get started but has some disadvantages.

**Please note that in contrast to the GET endpoint, points are specified in the order of `[longitude, latitude]`** and some parameter names use the plural.
For example the string `point=10,11&point=20,22` will be converted to the `points` array (plural):
```json
{ "points": [[11,10], [22,20]] }
```
So this `points` array uses a format similar to [GeoJson](http://geojson.org/geojson-spec.html#examples).

Example:
```bash
curl -X POST -H "Content-Type: application/json" "https://graphhopper.com/api/1/route?key=[YOUR_KEY]" -d '{"elevation":false,"points":[[-0.087891,51.534377],[-0.090637,51.467697]],"profile":"car"}'
```


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostRouteRequest
*/
func (a *RoutingAPIService) PostRoute(ctx context.Context) ApiPostRouteRequest {
	return ApiPostRouteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RouteResponse
func (a *RoutingAPIService) PostRouteExecute(r ApiPostRouteRequest) (*RouteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RouteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoutingAPIService.PostRoute")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/route"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.routeRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GHError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GHError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GHError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GHError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
