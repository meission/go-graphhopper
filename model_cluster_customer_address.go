/*
GraphHopper Directions API

 Integrate A-to-B route planning, turn-by-turn navigation, route optimization, isochrone calculations, location clustering and other tools into your application.    ##### Authentication      1. [Sign up for GraphHopper](https://graphhopper.com/dashboard/#/signup)   2. [Create an API key](https://support.graphhopper.com/a/solutions/articles/44001976027)    Authenticate to the API by passing your key as a query parameter in every request.    ##### API Explorer    You can also try all API parts without registration in our [API explorer](https://explorer.graphhopper.com/).    ##### Client Libraries    To speed up development and make coding easier, we offer a [JavaScript client](https://github.com/graphhopper/directions-api-js-client) and a   [Java client](https://github.com/graphhopper/graphhopper/tree/master/client-hc).    ##### Optimize Response Speed    1. Reuse SSL/TLS sessions    You should utilize the SSL session to speed up responses after the initial response or use a library that does this. E.g. for Java the   [OkHttp library](https://square.github.io/okhttp/) automatically reuses SSL/TLS sessions and also the browser takes care of this automatically.   For python you can use the [`requests` library](https://requests.readthedocs.io/en/latest/user/advanced/): first you create a   session (`session = requests.Session()`) and then do requests only with this session instead of directly using \"requests\".    2. Bandwidth reduction    If you create your own client, make sure it supports http/2 and gzipped responses for best speed.   If you use the Matrix, the Route Optimization API or the  and want to solve large problems, we recommend you to reduce bandwidth   by [compressing your POST request](https://gist.github.com/karussell/82851e303ea7b3459b2dea01f18949f4) and specifying the header   as follows: `Content-Encoding: gzip`. This will also avoid the HTTP 413 error \"Request Entity Too Large\". 

API version: 1.0.0
Contact: support@graphhopper.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
)

// checks if the ClusterCustomerAddress type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &ClusterCustomerAddress{}

// ClusterCustomerAddress struct for ClusterCustomerAddress
type ClusterCustomerAddress struct {
	// Longitude
	Lon *float64 `json:"lon,omitempty"`
	// Latitude
	Lat *float64 `json:"lat,omitempty"`
	// Optional parameter. Provide a hint that includes only the street name for each address to better snap the coordinates (lon,lat) to road network. E.g. if there is an address or house with two or more neighboring streets you can control for which street the closest location is looked up.
	StreetHint *string `json:"street_hint,omitempty"`
}

// NewClusterCustomerAddress instantiates a new ClusterCustomerAddress object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewClusterCustomerAddress() *ClusterCustomerAddress {
	this := ClusterCustomerAddress{}
	return &this
}

// NewClusterCustomerAddressWithDefaults instantiates a new ClusterCustomerAddress object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewClusterCustomerAddressWithDefaults() *ClusterCustomerAddress {
	this := ClusterCustomerAddress{}
	return &this
}

// GetLon returns the Lon field value if set, zero value otherwise.
func (o *ClusterCustomerAddress) GetLon() float64 {
	if o == nil || IsNil(o.Lon) {
		var ret float64
		return ret
	}
	return *o.Lon
}

// GetLonOk returns a tuple with the Lon field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *ClusterCustomerAddress) GetLonOk() (*float64, bool) {
	if o == nil || IsNil(o.Lon) {
		return nil, false
	}
	return o.Lon, true
}

// HasLon returns a boolean if a field has been set.
func (o *ClusterCustomerAddress) HasLon() bool {
	if o != nil && !IsNil(o.Lon) {
		return true
	}

	return false
}

// SetLon gets a reference to the given float64 and assigns it to the Lon field.
func (o *ClusterCustomerAddress) SetLon(v float64) {
	o.Lon = &v
}

// GetLat returns the Lat field value if set, zero value otherwise.
func (o *ClusterCustomerAddress) GetLat() float64 {
	if o == nil || IsNil(o.Lat) {
		var ret float64
		return ret
	}
	return *o.Lat
}

// GetLatOk returns a tuple with the Lat field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *ClusterCustomerAddress) GetLatOk() (*float64, bool) {
	if o == nil || IsNil(o.Lat) {
		return nil, false
	}
	return o.Lat, true
}

// HasLat returns a boolean if a field has been set.
func (o *ClusterCustomerAddress) HasLat() bool {
	if o != nil && !IsNil(o.Lat) {
		return true
	}

	return false
}

// SetLat gets a reference to the given float64 and assigns it to the Lat field.
func (o *ClusterCustomerAddress) SetLat(v float64) {
	o.Lat = &v
}

// GetStreetHint returns the StreetHint field value if set, zero value otherwise.
func (o *ClusterCustomerAddress) GetStreetHint() string {
	if o == nil || IsNil(o.StreetHint) {
		var ret string
		return ret
	}
	return *o.StreetHint
}

// GetStreetHintOk returns a tuple with the StreetHint field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *ClusterCustomerAddress) GetStreetHintOk() (*string, bool) {
	if o == nil || IsNil(o.StreetHint) {
		return nil, false
	}
	return o.StreetHint, true
}

// HasStreetHint returns a boolean if a field has been set.
func (o *ClusterCustomerAddress) HasStreetHint() bool {
	if o != nil && !IsNil(o.StreetHint) {
		return true
	}

	return false
}

// SetStreetHint gets a reference to the given string and assigns it to the StreetHint field.
func (o *ClusterCustomerAddress) SetStreetHint(v string) {
	o.StreetHint = &v
}

func (o ClusterCustomerAddress) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o ClusterCustomerAddress) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	if !IsNil(o.Lon) {
		toSerialize["lon"] = o.Lon
	}
	if !IsNil(o.Lat) {
		toSerialize["lat"] = o.Lat
	}
	if !IsNil(o.StreetHint) {
		toSerialize["street_hint"] = o.StreetHint
	}
	return toSerialize, nil
}

type NullableClusterCustomerAddress struct {
	value *ClusterCustomerAddress
	isSet bool
}

func (v NullableClusterCustomerAddress) Get() *ClusterCustomerAddress {
	return v.value
}

func (v *NullableClusterCustomerAddress) Set(val *ClusterCustomerAddress) {
	v.value = val
	v.isSet = true
}

func (v NullableClusterCustomerAddress) IsSet() bool {
	return v.isSet
}

func (v *NullableClusterCustomerAddress) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableClusterCustomerAddress(val *ClusterCustomerAddress) *NullableClusterCustomerAddress {
	return &NullableClusterCustomerAddress{value: val, isSet: true}
}

func (v NullableClusterCustomerAddress) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableClusterCustomerAddress) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


