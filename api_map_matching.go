/*
GraphHopper Directions API

 Integrate A-to-B route planning, turn-by-turn navigation, route optimization, isochrone calculations, location clustering and other tools into your application.    ##### Authentication      1. [Sign up for GraphHopper](https://graphhopper.com/dashboard/#/signup)   2. [Create an API key](https://support.graphhopper.com/a/solutions/articles/44001976027)    Authenticate to the API by passing your key as a query parameter in every request.    ##### API Explorer    You can also try all API parts without registration in our [API explorer](https://explorer.graphhopper.com/).    ##### Client Libraries    To speed up development and make coding easier, we offer a [JavaScript client](https://github.com/graphhopper/directions-api-js-client) and a   [Java client](https://github.com/graphhopper/graphhopper/tree/master/client-hc).    ##### Optimize Response Speed    1. Reuse SSL/TLS sessions    You should utilize the SSL session to speed up responses after the initial response or use a library that does this. E.g. for Java the   [OkHttp library](https://square.github.io/okhttp/) automatically reuses SSL/TLS sessions and also the browser takes care of this automatically.   For python you can use the [`requests` library](https://requests.readthedocs.io/en/latest/user/advanced/): first you create a   session (`session = requests.Session()`) and then do requests only with this session instead of directly using \"requests\".    2. Bandwidth reduction    If you create your own client, make sure it supports http/2 and gzipped responses for best speed.   If you use the Matrix, the Route Optimization API or the  and want to solve large problems, we recommend you to reduce bandwidth   by [compressing your POST request](https://gist.github.com/karussell/82851e303ea7b3459b2dea01f18949f4) and specifying the header   as follows: `Content-Encoding: gzip`. This will also avoid the HTTP 413 error \"Request Entity Too Large\". 

API version: 1.0.0
Contact: support@graphhopper.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
)


// MapMatchingAPIService MapMatchingAPI service
type MapMatchingAPIService service

type ApiPostGPXRequest struct {
	ctx context.Context
	ApiService *MapMatchingAPIService
	gpsAccuracy *int32
	profile *string
	locale *string
	elevation *bool
	details *[]string
	instructions *bool
	calcPoints *bool
	pointsEncoded *bool
}

// Specify the precision of a point, in meter
func (r ApiPostGPXRequest) GpsAccuracy(gpsAccuracy int32) ApiPostGPXRequest {
	r.gpsAccuracy = &gpsAccuracy
	return r
}

func (r ApiPostGPXRequest) Profile(profile string) ApiPostGPXRequest {
	r.profile = &profile
	return r
}

// The locale of the resulting turn instructions. E.g. &#x60;pt_PT&#x60; for Portuguese or &#x60;de&#x60; for German. 
func (r ApiPostGPXRequest) Locale(locale string) ApiPostGPXRequest {
	r.locale = &locale
	return r
}

// If &#x60;true&#x60;, a third coordinate, the altitude, is included with all positions in the response. This changes the format of the &#x60;points&#x60; and &#x60;snapped_waypoints&#x60; fields of the response, in both their encodings. Unless you switch off the &#x60;points_encoded&#x60; parameter, you need special code on the client side that can handle three-dimensional coordinates. 
func (r ApiPostGPXRequest) Elevation(elevation bool) ApiPostGPXRequest {
	r.elevation = &elevation
	return r
}

// Optional parameter. The following path details are available: &#x60;street_name&#x60;, &#x60;street_ref&#x60;, &#x60;street_destination&#x60;, &#x60;leg_time&#x60;, &#x60;leg_distance&#x60;, &#x60;roundabout&#x60;, &#x60;country&#x60;, &#x60;time&#x60;, &#x60;distance&#x60;, &#x60;max_speed&#x60;, &#x60;max_weight&#x60;, &#x60;max_width&#x60;, &#x60;toll&#x60;, &#x60;road_class&#x60;, &#x60;road_class_link&#x60;, &#x60;road_access&#x60;, &#x60;road_environment&#x60;, &#x60;hazmat&#x60;, &#x60;hazmat_tunnel&#x60;, &#x60;hazmat_water&#x60;,  &#x60;lanes&#x60;, &#x60;surface&#x60;, &#x60;smoothness&#x60;, &#x60;hike_rating&#x60;, &#x60;mtb_rating&#x60;, &#x60;foot_network&#x60;, &#x60;bike_network&#x60;. Read more about the usage of path details [here](https://discuss.graphhopper.com/t/2539). 
func (r ApiPostGPXRequest) Details(details []string) ApiPostGPXRequest {
	r.details = &details
	return r
}

// If instructions should be calculated and returned 
func (r ApiPostGPXRequest) Instructions(instructions bool) ApiPostGPXRequest {
	r.instructions = &instructions
	return r
}

// If the points for the route should be calculated at all. 
func (r ApiPostGPXRequest) CalcPoints(calcPoints bool) ApiPostGPXRequest {
	r.calcPoints = &calcPoints
	return r
}

// Allows changing the encoding of location data in the response. The default is polyline encoding, which is compact but requires special client code to unpack. (We provide it in our JavaScript client library!) Set this parameter to &#x60;false&#x60; to switch the encoding to simple coordinate pairs like &#x60;[lon,lat]&#x60;, or &#x60;[lon,lat,elevation]&#x60;. See the description of the response format for more information. 
func (r ApiPostGPXRequest) PointsEncoded(pointsEncoded bool) ApiPostGPXRequest {
	r.pointsEncoded = &pointsEncoded
	return r
}

func (r ApiPostGPXRequest) Execute() (*RouteResponse, *http.Response, error) {
	return r.ApiService.PostGPXExecute(r)
}

/*
PostGPX Map-match a GPX file

To get a match response you send a GPX file in the body of an HTTP POST request and specify request parameters like the `key` and `profile` in the URL.
See below for more supported parameters.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostGPXRequest
*/
func (a *MapMatchingAPIService) PostGPX(ctx context.Context) ApiPostGPXRequest {
	return ApiPostGPXRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RouteResponse
func (a *MapMatchingAPIService) PostGPXExecute(r ApiPostGPXRequest) (*RouteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RouteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MapMatchingAPIService.PostGPX")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/match"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.gpsAccuracy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gps_accuracy", r.gpsAccuracy, "form", "")
	}
	if r.profile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profile", r.profile, "form", "")
	} else {
		var defaultValue string = "car"
		r.profile = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "form", "")
	} else {
		var defaultValue string = "en"
		r.locale = &defaultValue
	}
	if r.elevation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "elevation", r.elevation, "form", "")
	} else {
		var defaultValue bool = false
		r.elevation = &defaultValue
	}
	if r.details != nil {
		t := *r.details
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "details", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "details", t, "form", "multi")
		}
	}
	if r.instructions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instructions", r.instructions, "form", "")
	} else {
		var defaultValue bool = true
		r.instructions = &defaultValue
	}
	if r.calcPoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "calc_points", r.calcPoints, "form", "")
	} else {
		var defaultValue bool = true
		r.calcPoints = &defaultValue
	}
	if r.pointsEncoded != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "points_encoded", r.pointsEncoded, "form", "")
	} else {
		var defaultValue bool = true
		r.pointsEncoded = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/gpx+xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
