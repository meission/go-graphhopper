/*
GraphHopper Directions API

 Integrate A-to-B route planning, turn-by-turn navigation, route optimization, isochrone calculations, location clustering and other tools into your application.    ##### Authentication      1. [Sign up for GraphHopper](https://graphhopper.com/dashboard/#/signup)   2. [Create an API key](https://support.graphhopper.com/a/solutions/articles/44001976027)    Authenticate to the API by passing your key as a query parameter in every request.    ##### API Explorer    You can also try all API parts without registration in our [API explorer](https://explorer.graphhopper.com/).    ##### Client Libraries    To speed up development and make coding easier, we offer a [JavaScript client](https://github.com/graphhopper/directions-api-js-client) and a   [Java client](https://github.com/graphhopper/graphhopper/tree/master/client-hc).    ##### Optimize Response Speed    1. Reuse SSL/TLS sessions    You should utilize the SSL session to speed up responses after the initial response or use a library that does this. E.g. for Java the   [OkHttp library](https://square.github.io/okhttp/) automatically reuses SSL/TLS sessions and also the browser takes care of this automatically.   For python you can use the [`requests` library](https://requests.readthedocs.io/en/latest/user/advanced/): first you create a   session (`session = requests.Session()`) and then do requests only with this session instead of directly using \"requests\".    2. Bandwidth reduction    If you create your own client, make sure it supports http/2 and gzipped responses for best speed.   If you use the Matrix, the Route Optimization API or the  and want to solve large problems, we recommend you to reduce bandwidth   by [compressing your POST request](https://gist.github.com/karussell/82851e303ea7b3459b2dea01f18949f4) and specifying the header   as follows: `Content-Encoding: gzip`. This will also avoid the HTTP 413 error \"Request Entity Too Large\". 

API version: 1.0.0
Contact: support@graphhopper.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"bytes"
	"fmt"
)

// checks if the Address type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &Address{}

// Address struct for Address
type Address struct {
	// Specifies the id of the location.
	LocationId string `json:"location_id"`
	// Name of location.
	Name *string `json:"name,omitempty"`
	// Longitude of location.
	Lon float64 `json:"lon"`
	// Latitude of location.
	Lat float64 `json:"lat"`
	// Optional parameter. Provide a hint that includes only the street name for each address to better snap the coordinates (lon,lat) to road network. E.g. if there is an address or house with two or more neighboring streets you can control for which street the closest location is looked up.
	StreetHint *string `json:"street_hint,omitempty"`
	// Optional parameter. Specifies on which side a point should be relative to the driver when she leaves/arrives at a start/target/via point. Only supported for motor vehicles and OpenStreetMap.
	Curbside *string `json:"curbside,omitempty"`
}

type _Address Address

// NewAddress instantiates a new Address object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewAddress(locationId string, lon float64, lat float64) *Address {
	this := Address{}
	this.LocationId = locationId
	this.Lon = lon
	this.Lat = lat
	var curbside string = "any"
	this.Curbside = &curbside
	return &this
}

// NewAddressWithDefaults instantiates a new Address object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewAddressWithDefaults() *Address {
	this := Address{}
	var curbside string = "any"
	this.Curbside = &curbside
	return &this
}

// GetLocationId returns the LocationId field value
func (o *Address) GetLocationId() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.LocationId
}

// GetLocationIdOk returns a tuple with the LocationId field value
// and a boolean to check if the value has been set.
func (o *Address) GetLocationIdOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.LocationId, true
}

// SetLocationId sets field value
func (o *Address) SetLocationId(v string) {
	o.LocationId = v
}

// GetName returns the Name field value if set, zero value otherwise.
func (o *Address) GetName() string {
	if o == nil || IsNil(o.Name) {
		var ret string
		return ret
	}
	return *o.Name
}

// GetNameOk returns a tuple with the Name field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Address) GetNameOk() (*string, bool) {
	if o == nil || IsNil(o.Name) {
		return nil, false
	}
	return o.Name, true
}

// HasName returns a boolean if a field has been set.
func (o *Address) HasName() bool {
	if o != nil && !IsNil(o.Name) {
		return true
	}

	return false
}

// SetName gets a reference to the given string and assigns it to the Name field.
func (o *Address) SetName(v string) {
	o.Name = &v
}

// GetLon returns the Lon field value
func (o *Address) GetLon() float64 {
	if o == nil {
		var ret float64
		return ret
	}

	return o.Lon
}

// GetLonOk returns a tuple with the Lon field value
// and a boolean to check if the value has been set.
func (o *Address) GetLonOk() (*float64, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Lon, true
}

// SetLon sets field value
func (o *Address) SetLon(v float64) {
	o.Lon = v
}

// GetLat returns the Lat field value
func (o *Address) GetLat() float64 {
	if o == nil {
		var ret float64
		return ret
	}

	return o.Lat
}

// GetLatOk returns a tuple with the Lat field value
// and a boolean to check if the value has been set.
func (o *Address) GetLatOk() (*float64, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Lat, true
}

// SetLat sets field value
func (o *Address) SetLat(v float64) {
	o.Lat = v
}

// GetStreetHint returns the StreetHint field value if set, zero value otherwise.
func (o *Address) GetStreetHint() string {
	if o == nil || IsNil(o.StreetHint) {
		var ret string
		return ret
	}
	return *o.StreetHint
}

// GetStreetHintOk returns a tuple with the StreetHint field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Address) GetStreetHintOk() (*string, bool) {
	if o == nil || IsNil(o.StreetHint) {
		return nil, false
	}
	return o.StreetHint, true
}

// HasStreetHint returns a boolean if a field has been set.
func (o *Address) HasStreetHint() bool {
	if o != nil && !IsNil(o.StreetHint) {
		return true
	}

	return false
}

// SetStreetHint gets a reference to the given string and assigns it to the StreetHint field.
func (o *Address) SetStreetHint(v string) {
	o.StreetHint = &v
}

// GetCurbside returns the Curbside field value if set, zero value otherwise.
func (o *Address) GetCurbside() string {
	if o == nil || IsNil(o.Curbside) {
		var ret string
		return ret
	}
	return *o.Curbside
}

// GetCurbsideOk returns a tuple with the Curbside field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Address) GetCurbsideOk() (*string, bool) {
	if o == nil || IsNil(o.Curbside) {
		return nil, false
	}
	return o.Curbside, true
}

// HasCurbside returns a boolean if a field has been set.
func (o *Address) HasCurbside() bool {
	if o != nil && !IsNil(o.Curbside) {
		return true
	}

	return false
}

// SetCurbside gets a reference to the given string and assigns it to the Curbside field.
func (o *Address) SetCurbside(v string) {
	o.Curbside = &v
}

func (o Address) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o Address) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	toSerialize["location_id"] = o.LocationId
	if !IsNil(o.Name) {
		toSerialize["name"] = o.Name
	}
	toSerialize["lon"] = o.Lon
	toSerialize["lat"] = o.Lat
	if !IsNil(o.StreetHint) {
		toSerialize["street_hint"] = o.StreetHint
	}
	if !IsNil(o.Curbside) {
		toSerialize["curbside"] = o.Curbside
	}
	return toSerialize, nil
}

func (o *Address) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"location_id",
		"lon",
		"lat",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err;
	}

	for _, requiredProperty := range(requiredProperties) {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varAddress := _Address{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varAddress)

	if err != nil {
		return err
	}

	*o = Address(varAddress)

	return err
}

type NullableAddress struct {
	value *Address
	isSet bool
}

func (v NullableAddress) Get() *Address {
	return v.value
}

func (v *NullableAddress) Set(val *Address) {
	v.value = val
	v.isSet = true
}

func (v NullableAddress) IsSet() bool {
	return v.isSet
}

func (v *NullableAddress) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableAddress(val *Address) *NullableAddress {
	return &NullableAddress{value: val, isSet: true}
}

func (v NullableAddress) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableAddress) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


