/*
GraphHopper Directions API

 Integrate A-to-B route planning, turn-by-turn navigation, route optimization, isochrone calculations, location clustering and other tools into your application.    ##### Authentication      1. [Sign up for GraphHopper](https://graphhopper.com/dashboard/#/signup)   2. [Create an API key](https://support.graphhopper.com/a/solutions/articles/44001976027)    Authenticate to the API by passing your key as a query parameter in every request.    ##### API Explorer    You can also try all API parts without registration in our [API explorer](https://explorer.graphhopper.com/).    ##### Client Libraries    To speed up development and make coding easier, we offer a [JavaScript client](https://github.com/graphhopper/directions-api-js-client) and a   [Java client](https://github.com/graphhopper/graphhopper/tree/master/client-hc).    ##### Optimize Response Speed    1. Reuse SSL/TLS sessions    You should utilize the SSL session to speed up responses after the initial response or use a library that does this. E.g. for Java the   [OkHttp library](https://square.github.io/okhttp/) automatically reuses SSL/TLS sessions and also the browser takes care of this automatically.   For python you can use the [`requests` library](https://requests.readthedocs.io/en/latest/user/advanced/): first you create a   session (`session = requests.Session()`) and then do requests only with this session instead of directly using \"requests\".    2. Bandwidth reduction    If you create your own client, make sure it supports http/2 and gzipped responses for best speed.   If you use the Matrix, the Route Optimization API or the  and want to solve large problems, we recommend you to reduce bandwidth   by [compressing your POST request](https://gist.github.com/karussell/82851e303ea7b3459b2dea01f18949f4) and specifying the header   as follows: `Content-Encoding: gzip`. This will also avoid the HTTP 413 error \"Request Entity Too Large\". 

API version: 1.0.0
Contact: support@graphhopper.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"bytes"
	"fmt"
)

// checks if the Objective type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &Objective{}

// Objective struct for Objective
type Objective struct {
	// Type of objective function, i.e. `min` or `min-max`.   * `min`: Minimizes the objective value.  * `min-max`: Minimizes the maximum objective value.  For instance, `min` -> `vehicles` minimizes the number of employed vehicles. `min` -> `completion_time` minimizes the sum of your vehicle routes' completion time.  If you use, for example, `min-max` -> `completion_time`, it minimizes the maximum of your vehicle routes' completion time, i.e. it minimizes the overall makespan. This only makes sense if you have more than one vehicle. In case of one vehicle, switching from `min` to `min-max` should not have any impact. If you have more than one vehicle, then the algorithm tries to constantly move stops from one vehicle to another such that the completion time of longest vehicle route can be further reduced. For example, if you have one vehicle that takes 8 hours to serve all customers, adding another vehicle (and using `min-max`) might halve the time to serve all customers to 4 hours. However, this usually comes with higher transport costs.  If you want to minimize `vehicles` first and, second, `completion_time`, you can also combine different objectives like this:  ```json \"objectives\" : [    {       \"type\": \"min\",       \"value\": \"vehicles\"    },    {       \"type\": \"min\",       \"value\": \"completion_time\"    } ] ```  If you want to balance activities or the number of stops among all employed drivers, you need to specify it as follows:  ```json \"objectives\" : [    {       \"type\": \"min-max\",       \"value\": \"completion_time\"    },    {       \"type\": \"min-max\",       \"value\": \"activities\"    } ] ``` 
	Type string `json:"type"`
	// The value of the objective function. The objective value `transport_time` solely considers the time your drivers spend on the road, i.e. transport time. In contrary to `transport_time`, `completion_time` also takes waiting times at customer sites into account. The `completion_time` of a route is defined as the time from starting to ending the route, i.e. the route's transport time, the sum of waiting times plus the sum of activity durations.  The `completion_time_last_stop`, on the other hand, refers to the completion time of the very last order in a tour or, in other words,  the completion time without the last section from the last stop to the end of the tour.  This is typically used if the orders are to be processed as quickly as possible. The objective value `vehicles` can only be used along with `min` and minimizes vehicles. 
	Value string `json:"value"`
}

type _Objective Objective

// NewObjective instantiates a new Objective object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewObjective(type_ string, value string) *Objective {
	this := Objective{}
	this.Type = type_
	this.Value = value
	return &this
}

// NewObjectiveWithDefaults instantiates a new Objective object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewObjectiveWithDefaults() *Objective {
	this := Objective{}
	var type_ string = "min"
	this.Type = type_
	var value string = "transport_time"
	this.Value = value
	return &this
}

// GetType returns the Type field value
func (o *Objective) GetType() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.Type
}

// GetTypeOk returns a tuple with the Type field value
// and a boolean to check if the value has been set.
func (o *Objective) GetTypeOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Type, true
}

// SetType sets field value
func (o *Objective) SetType(v string) {
	o.Type = v
}

// GetValue returns the Value field value
func (o *Objective) GetValue() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.Value
}

// GetValueOk returns a tuple with the Value field value
// and a boolean to check if the value has been set.
func (o *Objective) GetValueOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Value, true
}

// SetValue sets field value
func (o *Objective) SetValue(v string) {
	o.Value = v
}

func (o Objective) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o Objective) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	toSerialize["type"] = o.Type
	toSerialize["value"] = o.Value
	return toSerialize, nil
}

func (o *Objective) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"type",
		"value",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err;
	}

	for _, requiredProperty := range(requiredProperties) {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varObjective := _Objective{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varObjective)

	if err != nil {
		return err
	}

	*o = Objective(varObjective)

	return err
}

type NullableObjective struct {
	value *Objective
	isSet bool
}

func (v NullableObjective) Get() *Objective {
	return v.value
}

func (v *NullableObjective) Set(val *Objective) {
	v.value = val
	v.isSet = true
}

func (v NullableObjective) IsSet() bool {
	return v.isSet
}

func (v *NullableObjective) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableObjective(val *Objective) *NullableObjective {
	return &NullableObjective{value: val, isSet: true}
}

func (v NullableObjective) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableObjective) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


